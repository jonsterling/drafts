\documentclass[12pt]{article}
\usepackage{syntax}
\usepackage{semantic}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[parfill]{parskip}
\begin{document}
\title{Logical Relations}
\author{Danny Gratzer}
\date{\today}
\maketitle

\begin{abstract}
Logical relations are a powerful tool in PLT. In particular it
provides an elegant method of proving properties that don't follow
cleanly from obvious methods of induction.

In this ``paper'', we'll step through a proof of algorithmic
equivalence for STLC as well as parametricity in System F to motivate
and demonstrate logical relations.
\end{abstract}

\section{Introduction}
This paper is laid out into 5 parts. First we define a few key
concepts in simply typed lambda calculus (STLC) and as well as System
F. We'll also step through the definitions of a few basic judgments
such as typing.

We then set out on a doomed mission to prove the sanity of an
equivalence algorithm without major contortions or logical
relations.

Next we introduce logical relations and define such a relation across
STLC and System F. In this section we'll also prove that they have
pleasant properties

We'll then use these relationships to prove our algorithm and
parametricity respectively.

\section{Definitions}
In order to play with logical relations, we must first rigorously
answer one question: What does it mean for two expressions to be
``equal''.

The naive notion would simply be that be that if no matter how we use
two snippets, we should end up with the same results. We'll now
formalize what it means to use a ``snippet'' by defining a concept
called a hole.

A hole is exactly what it sounds like, a space where an expression can
be inserted into a program leaving a complete program behind. It's
almost like a faux-function where we textually modify the body of the
function. We can build up the syntactic sort for holes. I'll only show
the sort for STLC holes, but extending this to System F is straightforward.

\begin{grammar}
  <hole> ::= \circ
  \alt <hole> <hole>
  \alt \lambda <var>. <hole>
  \alt <exp>
\end{grammar}

So we notate the actual hole with $ \circ $, and other than that a whole
is more or less equivalent to an expression. A hole also should have a
special typing judgment which maps the type of the hole to the type of
the whole expression built around the hole.

Notice that we cleverly only allow at most one hole in a typed hole
expression. We can have trivial holes where the expressions
supplied to fill the hole is just tossed on the floor.

Now that we have a definition a hole in a program, we can define
our interesting notion of equivalence.
\end{document}
